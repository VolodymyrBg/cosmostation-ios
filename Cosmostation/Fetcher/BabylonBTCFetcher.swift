//
//  BabylonBTCFetcher.swift
//  Cosmostation
//
//  Created by 차소민 on 2/24/25.
//  Copyright © 2025 wannabit. All rights reserved.
//

import Foundation
import SwiftyJSON
import Alamofire
import GRPC
import NIO

// MARK: BTC staking
class BabylonBTCFetcher {
    var chain: BaseChain!

    var btcDelegations = [BtcDelegation]()
    var btcStakingAmount: NSDecimalNumber = .zero
    var btcUnstakingAmount: NSDecimalNumber = .zero
    var btcWithdrawableAmount: NSDecimalNumber = .zero
    var finalityProviders = [FinalityProvider]()
    var btcStakedRewards = [Cosmos_Base_V1beta1_Coin]()

    var btcStakingTimeLockWeeks = 0
    var btcUnbondingTimeDays = 0
    
    var networkInfo: [JSON] = []
    
    var unbondingFeeSat: Int64?
    
    var grpcConnection: ClientConnection?

    init(_ chain: BaseChain) {
        self.chain = chain
    }
    
    
    func fetchBtcStakingData() async -> Bool {
        btcDelegations = []
        btcStakedRewards = []
        
        var delegations: [JSON] = []
        
        do {
            // babylon
            if let chain = (chain as? ChainBabylon) {
                
                btcStakingAmount = try await fetchBtcDelegationAmount(chain.bechAddress!)
                btcStakedRewards = await fetchBtcStakedRewards()
                
            //bitcoin
            } else if let chain = (chain as? ChainBitCoin86),
                      chain.isSupportBTCStaking() {
                if let delegationsResult = try await fetchBtcDelegations() {
                    delegations = delegationsResult
                } else {
                    return false
                }
                
                if let params = try await fetchParams() {
                    unbondingFeeSat = params.unbondingFeeSat
                    
                    let blockPerHour = 6.0
                    
                    let stakingBlock = Double(params.maxStakingTimeBlocks)
                    let stakingHour = stakingBlock / blockPerHour
                    btcStakingTimeLockWeeks = Int((stakingHour / 24 / 7 / 5).rounded() * 5)
                    
                    let unbondingBlock = Double(params.unbondingTimeBlocks)
                    let unbondingHour = unbondingBlock / blockPerHour
                    btcUnbondingTimeDays = Int((unbondingHour / 24))
                }
                if finalityProviders.isEmpty {
                    delegations.forEach { delegation in
                        self.btcDelegations.append(BtcDelegation.init(delegation, nil))
                    }
                } else {
                    delegations.forEach { delegation in
                        let provider = finalityProviders.filter({ $0.btcPk == delegation["finality_provider_btc_pks_hex"].array?.first?.stringValue}).first
                        self.btcDelegations.append(BtcDelegation.init(delegation, provider))
                    }
                }
                
                let stakingAmount = btcDelegations.filter({ $0.state.uppercased() == "ACTIVE"}).map({ $0.amount }).reduce(0, +)
                btcStakingAmount = NSDecimalNumber(integerLiteral: stakingAmount)
                let unstakingAmount = btcDelegations.filter({$0.state.uppercased() == "TIMELOCK_UNBONDING" || $0.state.uppercased() == "EARLY_UNBONDING"}).map({ $0.amount }).reduce(0, +)
                btcUnstakingAmount = NSDecimalNumber(integerLiteral: unstakingAmount)
                let withdrawableAmount = btcDelegations.filter({ $0.state.uppercased().contains("WITHDRAWABLE") }).map({ $0.amount }).reduce(0, +)
                btcWithdrawableAmount = NSDecimalNumber(integerLiteral: withdrawableAmount)
                
                btcDelegations.sort {
                    if let a = WUtils.timeStringToDate($0.inceptionTime),
                       let b = WUtils.timeStringToDate($1.inceptionTime) {
                        return a > b
                    } else {
                        return true
                    }
                }
            }
            
            return true

        } catch {
            print("fetchBtcStakingData error \(error)")
            return false
        }
    }
    
    func fetchFinalityProvidersInfo() async -> Bool {
        if (!finalityProviders.isEmpty) { return true }

        do {
            try await fetchFinalityProviders().forEach { provider in
                self.finalityProviders.append(FinalityProvider(provider, "0"))
                
                for (index, delegation) in btcDelegations.enumerated() {
                    if let provider = finalityProviders.filter({ $0.btcPk == delegation.providerPk }).first {
                        btcDelegations[index].updateDelegationProviderInfo(provider)
                    }
                }

            }
            return true
            
        } catch {
            print("fetchFinalityProvidersInfo error \(error)")
            return false
        }
    }
    
    func updateProvidersVotingPower() async {
        do {
            let height = try await fetchStatusHeight()
            let votingPowerList = try await fetchProvidersVotingPower(height)
            
            for (index, provider) in finalityProviders.enumerated() {
                let btcPk = provider.btcPk
                if let votingPower = votingPowerList.filter({ $0.btcPkHex == btcPk }).first?.votingPower {
                    finalityProviders[index].updateProvidersVotingPower(String(votingPower))
                }
            }
            
            finalityProviders.sort {
                if ($0.moniker == "Cosmostation") { return true }
                if ($1.moniker == "Cosmostation") { return false }
                if ($0.jailed && !$1.jailed) { return false }
                if (!$0.jailed && $1.jailed) { return true }
                return Double($0.votingPower)! > Double($1.votingPower)!
            }
            
        } catch {
            print("updateProvidersVotingPower Error", error)
        }
    }
    
    func btcStakingRewardAmountSum(_ denom: String) -> NSDecimalNumber {
        var result =  NSDecimalNumber.zero
        result = result.adding(NSDecimalNumber(string: btcStakedRewards.filter{ $0.denom == denom }.first?.amount ?? "0"))
        return result
    }
    
    func rewardOtherDenomTypeCnts() -> Int {
        var denoms = [String]()
        btcStakedRewards.filter { $0.denom != chain.stakingAssetDenom() }.forEach { reward in
            if (denoms.contains(reward.denom) == false) {
                denoms.append(reward.denom)
            }
        }
        return denoms.count
    }
}

// MARK: grpc, lcd Fetch
extension BabylonBTCFetcher {
    
    func fetchParams() async throws -> Babylon_Btcstaking_V1_Params? {
        if (getEndpointType() == .UseGRPC) {
            let req = Babylon_Btcstaking_V1_QueryParamsRequest()
            return try await Babylon_Btcstaking_V1_QueryNIOClient(channel: getClient()).params(req, callOptions: getCallOptions()).response.get().params
            
        } else {
            let url = getLcd() + "babylon/btcstaking/v1/params"
            let response = try await AF.request(url, method: .get).serializingDecodable(JSON.self).value["params"]
            return response.params()
        }
    }
    
    func fetchFinalityProviders() async throws -> [Babylon_Btcstaking_V1_FinalityProviderResponse] {
        if (getEndpointType() == .UseGRPC) {
            let pagination = Cosmos_Base_Query_V1beta1_PageRequest.with { $0.limit = 300 }
            let req = Babylon_Btcstaking_V1_QueryFinalityProvidersRequest.with { $0.pagination = pagination }
            return try await Babylon_Btcstaking_V1_QueryNIOClient(channel: getClient()).finalityProviders(req, callOptions: getCallOptions()).response.get().finalityProviders

        } else {
            let url = getLcd() + "babylon/btcstaking/v1/finality_providers?pagination.limit=300"
            let response = try await AF.request(url, method: .get).serializingDecodable(JSON.self).value
            return response.finalityProviders()
        }
    }

    func fetchStatusHeight() async throws -> String {
        if (getEndpointType() == .UseGRPC) {
            let req = Cosmos_Base_Node_V1beta1_StatusRequest()
            let height = try await Cosmos_Base_Node_V1beta1_ServiceNIOClient(channel: getClient()).status(req, callOptions: getCallOptions()).response.get().height
            return String(height)
        
        } else {
            let url = getLcd() + "cosmos/base/node/v1beta1/status"
            return try await AF.request(url, method: .get).serializingDecodable(JSON.self).value["height"].stringValue
        }
    }
    
    func fetchProvidersVotingPower(_ height: String) async throws -> [Babylon_Finality_V1_ActiveFinalityProvidersAtHeightResponse] {
        let url = getLcd() + "babylon/finality/v1/finality_providers/" + height
        return try await AF.request(url, method: .get).serializingDecodable(JSON.self).value.finalityProviderWithVotingPower()
    }
    
    func fetchBtcStakedRewards() async -> [Cosmos_Base_V1beta1_Coin] {
        do {
            if (getEndpointType() == .UseGRPC) {
                let req = Babylon_Incentive_QueryRewardGaugesRequest.with { $0.address = chain.bechAddress! }
                let rewardGauges = try await Babylon_Incentive_QueryNIOClient(channel: getClient()).rewardGauges(req, callOptions: getCallOptions()).response.get().rewardGauges
                var result = [Cosmos_Base_V1beta1_Coin]()
                                
                rewardGauges["BTC_STAKER"]?.coins.forEach({ coin in
                    if let withdrawn = rewardGauges["BTC_STAKER"]?.withdrawnCoins.filter({ $0.denom == coin.denom }).first {
                        let amount = (UInt64(coin.amount) ?? 0) - (UInt64(withdrawn.amount) ?? 0)
                        result.append(Cosmos_Base_V1beta1_Coin(coin.denom, String(amount)))
                    } else {
                        result.append(coin)
                    }
                })
                return result
                
            } else {
                let url = getLcd() + "babylon/incentive/address/" + chain.bechAddress! + "/reward_gauge"
                let rewardGauges = try await AF.request(url, method: .get).serializingDecodable(JSON.self).value["reward_gauges"]["BTC_STAKER"]
                var result = [Cosmos_Base_V1beta1_Coin]()
                
                rewardGauges["coins"].arrayValue.forEach({ coin in
                    if let withdrawn = rewardGauges["withdrawn_coins"].arrayValue.filter({ $0["denom"].stringValue == coin["denom"].stringValue }).first {
                        let amount = (UInt64(coin["amount"].stringValue) ?? 0) - (UInt64(withdrawn["amount"].stringValue) ?? 0)
                        result.append(Cosmos_Base_V1beta1_Coin(coin["denom"].stringValue, String(amount)))
                    } else {
                        result.append(Cosmos_Base_V1beta1_Coin(coin["denom"].stringValue,coin["amount"].stringValue))
                    }
                })
                return result
            }
            
        } catch {
            print("Error: \(#function)")
            return []
        }
    }
    
    func fetchTipHeight() async throws -> JSON {
        let url = getLcd() + "babylon/btclightclient/v1/tip"
        let response = try await AF.request(url, method: .get).serializingDecodable(JSON.self).value["header"]
        return response
    }
    
    
    func fetchAvailableUTXOs(address: String) async throws -> [JSON] {
        do {
            guard let btcFetcher = (chain as? ChainBitCoin86)?.getBtcFetcher() else { return [] }
            var sortedUTXOs = try await btcFetcher.fetchUtxos() ?? []
            sortedUTXOs.sort { $0["value"].intValue > $1["value"].intValue }
            
            let validateInfo = try await btcFetcher.fetchValidate() ?? JSON()
            guard validateInfo["isvalid"].boolValue else {
                print("Invalid address")
                return []
            }
            let scriptPubKey = validateInfo["scriptPubKey"].stringValue

            let dataList = sortedUTXOs.map { utxo -> JSON in
                var updatedUTXO = utxo
                updatedUTXO["scriptPubKey"].stringValue = scriptPubKey
                return updatedUTXO
            }
            
            let confirmedList = dataList.filter { $0["status"]["confirmed"].boolValue }
            let filteredUTXOs = filterDust(confirmedList)

            let verifiedUTXOs = try await postVerifyUtxoOrdinals(utxos: filteredUTXOs, address: address)

            let ordinals = verifiedUTXOs.filter { $0["inscription"].boolValue }
            let ordinalMap = Dictionary(uniqueKeysWithValues: ordinals.map { ($0["txid"].stringValue, $0) })
            let availableUTXOs = filteredUTXOs.filter { ordinalMap[$0["txid"].stringValue] == nil }

            return availableUTXOs
        } catch {
            print("Error fetching UTXOs: \(error)")
            throw error
        }
    }

}

// MARK: - Helper Functions
extension BabylonBTCFetcher {
    func filterDust(_ utxos: [JSON], limit: Int = LOW_VALUE_UTXO_THRESHOLD) -> [JSON] {
        return utxos.filter { $0["value"].intValue > limit }
    }

    func chunkArray(_ array: [JSON], size: Int) -> [[JSON]] {
        return stride(from: 0, to: array.count, by: size).map {
            Array(array[$0..<min($0 + size, array.count)])
        }
    }
}

extension BabylonBTCFetcher {
    func fetchBtcDelegations(_ babylonAddr: String) async throws -> [JSON] {
        let limit = 60
        let url = MINTSCAN_API_URL + "v11/" + chain.apiName + "/btc/stakers"
        let param = "?limit=\(limit)&staker_addr=\(babylonAddr)"
        var searchAfter = ""
        
        var total = 0
        var result: [JSON] = []
        repeat {
            let pagination = "&search_after=\(searchAfter)"
            let value = try await AF.request(url+param+pagination).serializingDecodable(JSON.self).value
            let delegations = value["data"].arrayValue
            total = value["total"].intValue
            result.append(contentsOf: delegations)
            searchAfter = result.last?["search_after"].stringValue ?? ""
        } while !searchAfter.isEmpty && total > result.count
        
        return result
    }
    
    func fetchBtcDelegationAmount(_ babylonAddr: String) async throws -> NSDecimalNumber {
        let url = MINTSCAN_API_URL + "v11/" + chain.apiName + "/btc/staker/amount"
        let param = "?staker_addr=\(babylonAddr)&active=true"
        let value = try await AF.request(url+param).serializingDecodable(JSON.self).value
        let amount = value["data"].arrayValue.first?["amount"].uInt64Value ?? 0
        return NSDecimalNumber(value: amount)
    }

}

// MARK: babylon api fetch <limit> 50 reqs in 10 secs / 100 reqs in 1 min
extension BabylonBTCFetcher {
    func getBabylonApiUrl(_ version: Int? = 2) -> String{
        if chain.isTestnet {
            return "https://staking-api.testnet.babylonlabs.io/v\(version!)/"
        } else {
            return "https://staking-api.babylonlabs.io/v\(version!)/"
        }
    }
    
    
    func fetchBtcDelegations() async throws -> [JSON]? {
        if let btcPubKey = (chain as? ChainBitCoin86)?.publicKey?.toHexString() {
            let pubKey = String(btcPubKey.dropFirst(2)) //
            let url = getBabylonApiUrl() + "delegations?staker_pk_hex=" + pubKey
            return try await AF.request(url, method: .get).serializingDecodable(JSON.self).value["data"].array

        } else {
            return nil
        }
    }
    
    func fetchNetworkInfo() async throws {
        let url = getBabylonApiUrl() + "network-info"
        networkInfo = try await AF.request(url, method: .get).serializingDecodable(JSON.self).value["data"]["params"]["bbn"].arrayValue
    }
    
    func postVerifyUtxoOrdinals(utxos: [JSON], address: String) async throws -> [JSON] {
        let url = getBabylonApiUrl(1) + "ordinals/verify-utxos"
        
        let utxoChunks = chunkArray(utxos, size: BATCH_SIZE)

        var verifiedUTXOs: [JSON] = []

        for chunk in utxoChunks {
            let parameters: Parameters = [
                "address": address,
                "utxos": chunk.map { ["txid": $0["txid"].stringValue, "vout": $0["vout"].intValue] }
            ]

            do {
                let response = try await AF.request(url, method: .post, parameters: parameters, encoding: JSONEncoding.default).serializingDecodable(JSON.self).value
                let utxoInfos = response["data"].arrayValue
                utxoInfos.forEach { utxo in
                    verifiedUTXOs.append(JSON(["txid": utxo["txid"].stringValue,
                                   "vout": utxo["vout"].intValue,
                                   "value": utxo["value"].uInt64Value,
                                   "scriptPubKey": utxo["scriptPubKey"].stringValue,
                                   "confirmed": utxo["status"]["confirmed"].boolValue]))
                }
                
            } catch {
                print("UTXO verification failed: \(error)")
            }
        }

        return verifiedUTXOs
    }
}


extension BabylonBTCFetcher {
    func getLcd() -> String {
        let chain = chain.isTestnet ? ChainBabylon_T() : ChainBabylon()
        var url = ""
        if let endpoint = UserDefaults.standard.string(forKey: KEY_CHAIN_LCD_ENDPOINT +  " : " + chain.name) {
            url = endpoint
        } else {
            url = chain.lcdUrl
        }
        if (url.last != "/") {
            return url + "/"
        }
        return url
        
    }
    
    func getGrpc() -> (host: String, port: Int) {
        let chain = chain.isTestnet ? ChainBabylon_T() : ChainBabylon()
        if let endpoint = UserDefaults.standard.string(forKey: KEY_CHAIN_GRPC_ENDPOINT +  " : " + chain.name) {
            if (endpoint.components(separatedBy: ":").count == 2) {
                let host = endpoint.components(separatedBy: ":")[0].trimmingCharacters(in: .whitespaces)
                let port = Int(endpoint.components(separatedBy: ":")[1].trimmingCharacters(in: .whitespaces))
                return (host, port!)
            }
        }
        return (chain.grpcHost, chain.grpcPort)
        
    }
    
    func getEndpointType() -> CosmosEndPointType? {
        let chain = chain.isTestnet ? ChainBabylon_T() : ChainBabylon()
        let endpointType = UserDefaults.standard.integer(forKey: KEY_COSMOS_ENDPOINT_TYPE +  " : " + chain.name)
        if (endpointType == CosmosEndPointType.UseGRPC.rawValue) {
            return .UseGRPC
        } else if (endpointType == CosmosEndPointType.UseLCD.rawValue) {
            return .UseLCD
        } else {
            return chain.cosmosEndPointType
        }
    }
    func getClient() -> ClientConnection {
        if (grpcConnection == nil) {
            let group = PlatformSupport.makeEventLoopGroup(loopCount: 4)
            grpcConnection = ClientConnection.usingPlatformAppropriateTLS(for: group).connect(host: getGrpc().host, port: getGrpc().port)
        }
        return grpcConnection!
    }
    
    func getCallOptions() -> CallOptions {
        var callOptions = CallOptions()
        callOptions.timeLimit = TimeLimit.timeout(TimeAmount.milliseconds(20000))
        return callOptions
    }
}

// Delegation + FinalityProvider
struct BtcDelegation {
    var version: Int
    var providerPk: String
    var moniker: String
    var commission: String
    var jailed: Bool
    var inceptionTime: String
    var transactionID: String
    var stakingTxHex: String
    var amount: Int
    var state: String
    var delegationUnbonding: JSON
    var delegationStaking: JSON
    
    init(_ delegation: JSON, _ provider: FinalityProvider?) {
        version = delegation["params_version"].intValue
        providerPk = delegation["finality_provider_btc_pks_hex"].array?.first?.stringValue ?? ""
        moniker = provider?.moniker ?? ""
        commission = provider?.commission ?? "0"
        jailed = provider?.jailed ?? true
        inceptionTime = delegation["delegation_staking"]["bbn_inception_time"].stringValue
        transactionID = delegation["delegation_staking"]["staking_tx_hash_hex"].stringValue
        stakingTxHex = delegation["delegation_staking"]["staking_tx_hex"].stringValue
        amount = delegation["delegation_staking"]["staking_amount"].intValue
        state = delegation["state"].stringValue
        delegationUnbonding = delegation["delegation_unbonding"]
        delegationStaking = delegation["delegation_staking"]
    }
    
    mutating func updateDelegationProviderInfo(_ provider: FinalityProvider) {
        moniker = provider.moniker
        commission = provider.commission
        jailed = provider.jailed
    }
}

// FinalityProvider + votingPower
struct FinalityProvider {
    var moniker: String
    var commission: String
    var btcPk: String
    var votingPower: String
    var jailed: Bool
    
    init(_ provider: Babylon_Btcstaking_V1_FinalityProviderResponse, _ votingPower: String) {
        moniker = provider.description_p.moniker
        commission = provider.commission
        btcPk = provider.btcPk.toHexString()
        self.votingPower = votingPower
        jailed = provider.jailed
    }
    
    mutating func updateProvidersVotingPower(_ vp: String) {
        votingPower = vp
    }
}

extension JSON {
    func params() -> Babylon_Btcstaking_V1_Params {
        Babylon_Btcstaking_V1_Params.with { param in
            self["covenant_pks"].arrayValue.forEach({ pk in
                param.covenantPks.append(Data(hex: pk.stringValue))
            })
            param.covenantQuorum = self["covenant_quorum"].uInt32Value
            param.minStakingValueSat = Int64(self["min_staking_value_sat"].stringValue) ?? 0
            param.maxStakingValueSat = Int64(self["max_staking_value_sat"].stringValue) ?? 0
            param.minStakingTimeBlocks = self["min_staking_time_blocks"].uInt32Value
            param.maxStakingTimeBlocks = self["max_staking_time_blocks"].uInt32Value
            param.unbondingTimeBlocks = self["unbonding_time_blocks"].uInt32Value
            param.unbondingFeeSat = self["unbonding_fee_sat"].int64Value
        }
    }
    
    func finalityProviders() -> [Babylon_Btcstaking_V1_FinalityProviderResponse] {
        var result = [Babylon_Btcstaking_V1_FinalityProviderResponse]()
        self["finality_providers"].arrayValue.forEach { provider in
            let finalityProviderResponse = Babylon_Btcstaking_V1_FinalityProviderResponse.with {
                $0.description_p.moniker = provider["description"]["moniker"].stringValue
                $0.commission = provider["commission"].stringValue
                $0.btcPk = Data(hex: provider["btc_pk"].stringValue)
                $0.jailed = provider["jailed"].boolValue
            }
            result.append(finalityProviderResponse)
        }
        return result
    }
    
    func finalityProviderWithVotingPower() -> [Babylon_Finality_V1_ActiveFinalityProvidersAtHeightResponse] {
        var result = [Babylon_Finality_V1_ActiveFinalityProvidersAtHeightResponse]()
        
        self["finality_providers"].arrayValue.forEach { provider in
            let response = Babylon_Finality_V1_ActiveFinalityProvidersAtHeightResponse.with {
                $0.btcPkHex = provider["btc_pk_hex"].stringValue
                $0.votingPower = UInt64(provider["voting_power"].stringValue) ?? 0
            }
            result.append(response)
        }
        return result
    }
}

// MARK: - Constants
let LOW_VALUE_UTXO_THRESHOLD = 10000
let BATCH_SIZE = 30

